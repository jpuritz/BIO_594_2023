---
title: "SNPfiltR"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
#Install current release from CRAN
#install.packages("SNPfiltR")

library(SNPfiltR)
library(vcfR)
```


## Step 1: read in vcf file as ‘vcfR’ object
Because we are using the example dataset distributed with the package, we just load in the vcf and popmap using the data() function.

```{r}
#load the example vcfR object 
data(vcfR.example)

### check the metadata present in your vcf
vcfR.example

vcfR.example@fix[1:10,1:8]

vcfR.example@gt[1:10,1:2]

#Load the example popmap file. It is a standard two column popmap, where the first column must be named 'id' and contain individual sample identifiers matching the sample identifiers in the vcf file, and the second column must be named 'pop', and contain a population assignment for each sample.
data(popmap)
popmap
```


## Step 2: quality filtering
We now implement quality filters that don’t involve missing data. This is because removing low data samples will alter percentage/quantile based missing data cutoffs, so we wait to implement those until after deciding on our final set of samples for downstream analysis

```{r}
#generate exploratory visualizations of depth and genotype quality for all called genotypes
#hard_filter(vcfR=vcfR.example)

#hard filter to minimum depth of 5, and minimum genotype quality of 30
vcfR<-hard_filter(vcfR=vcfR.example, depth = 5, gq = 30)
```

Alternative filtering based on Jon's tutorial:

```{r}
#execute allele balance filter
vcfR<-filter_allele_balance(vcfR)
```


```{r}
#visualize and pick appropriate max depth cutoff
#max_depth(vcfR)
#not running here to save space on visualizations

#filter vcf by the max depth cutoff you chose
vcfR<-max_depth(vcfR, maxdepth = 100)
```

How many SNPs are left?
```{r}
#check vcfR to see how many SNPs we have left
vcfR
```

## Step 3: set missing data per sample cutoff

###Set arbitrary cutoff for missing data allowed per sample.

```{r}
#run function to visualize samples and return informative data.frame object
miss<-missing_by_sample(vcfR=vcfR)
```

```{r}

#run function to drop samples above the threshold we want from the vcf
#here I am setting a relatively lax cutoff
vcfR<-missing_by_sample(vcfR=vcfR, cutoff = .9)
```
```{r}

#remove invariant sites generated by sample trimming and genotype filtering
vcfR<-min_mac(vcfR, min.mac = 1)
```
```{r}

#update popmap by removing samples that have been filtered out
popmap<-popmap[popmap$id %in% colnames(vcfR@gt)[-1],]
```


## Step 4: set missing data per SNP cutoff

### Set arbitrary cutoff for missing data allowed per SNP.

```{r}
#visualize missing data by SNP and the effect of various cutoffs on the missingness of each sample
missing_by_snp(vcfR)
```

We can see that there are still some outlier samples with a lot of missing data even at high missing data per SNP thresholds, which is concerning. We will want to check whether this excess missing data in some samples is affecting overall clustering patterns using the functions assess_missing_data_pca() and assess_missing_data_tsne().

```{r}
#assess missing data effects on clustering
assess_missing_data_pca(vcfR = vcfR, popmap = popmap, thresholds = c(.8), clustering = FALSE)

assess_missing_data_tsne(vcfR = vcfR, popmap = popmap, thresholds = c(.8), clustering = FALSE)
```

We can see that at an 80% per SNP completeness cutoff, samples with an excess of missing data are leaking toward the center (specifically coerulescens samples), indicating that they can’t be reliably clustered due to excess missing data.

We can go back and target specific samples with too much missing data even at high filtering thresholds for removal using the following code:


```{r}
#show me the samples with the most missing data at an 80% completeness threshold
filt<-miss[miss$filt == .8,]
filt[order(filt$snps.retained),]

#drop the three samples with an excess of missing data at an 80% SNP completeness threshold
vcfR<- vcfR[,colnames(vcfR@gt) != "A_coerulescens_396263" & colnames(vcfR@gt) != "A_woodhouseii_334134" & colnames(vcfR@gt) != "A_coerulescens_396256"]

#remove invariant SNPs
vcfR<-min_mac(vcfR, min.mac = 1)
```

```{r}
vcfR

#update popmap by removing samples that have been filtered out
popmap<-popmap[popmap$id %in% colnames(vcfR@gt)[-1],]
```

Re-visualize data
```{r}
#visualize missing data at various completeness thresholds
missing_by_snp(vcfR)
```

```{r}
#all samples look good at most thresholds, because of the small size of this dataset, I will choose a 60% completeness threshold in order to retain as many SNPs as possible

#filter vcfR
vcfR<-missing_by_snp(vcfR, cutoff = .6)
```
## Step 5: quality unaware filters

We can now implement filters that are blind to genotype quality like a Minor Allele Count (MAC) threshold, and a distance-based filtering threshold, both of which may serve to increase the signal to noise ratio of our dataset in downstream analyses.

```{r}
#remove singletons (loci with only a single variant allele which have no phylogenetic signal)
vcfR<-min_mac(vcfR = vcfR, min.mac = 2)
```
```{r}
#linkage filter vcf to thin SNPs to one per 500bp
vcfR<-distance_thin(vcfR, min.distance = 500)

#look at final stats for our filtered vcf file
vcfR
```

## Step 6: write out files for downstream analysis

We can now use the convenient function vcfR::write.vcf() to export our filtered vcf file for downstream analyses

```{r}
#write out vcf
#vcfR::write.vcf(vcfR, file = "~/Downloads/scrub.jay.example.filtered.vcf.gz")
```


